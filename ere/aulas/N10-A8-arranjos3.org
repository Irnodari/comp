# -*- coding: utf-8 -*-
# -*- mode: org -*-
#+startup: beamer overview indent
#+LANGUAGE: pt-br
#+TAGS: noexport(n)
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXPORT_SELECT_TAGS: export

#+Title: Compiladores
#+Author: Prof. Lucas M. Schnorr (UFRGS)
#+Date: \copyleft

#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [xcolor=dvipsnames, aspectratio=169, presentation]
#+OPTIONS: title:nil H:1 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+LATEX_HEADER: \input{../org-babel.tex}

#+latex: \newcommand{\mytitle}{Esquemas para Arranjos}
#+latex: \mytitleslide

* Esquemas de Tradução (Declaração)
Gramática para declaração de arranjos multidimensionais
  | decl | \rightarrow | T *id* [ L ] |
  | T    | \rightarrow | *float*      |
  | L    | \rightarrow | L , D        |
  | L    | \rightarrow | D            |
  | D    | \rightarrow | N..N         |
  | N    | \rightarrow | *num*        |
\pause Precisamos um esquema de tradução para definir $C_A$ \\
  (repetindo o cálculo recursivo que permite obtê-lo)

#+BEGIN_EXPORT latex
  \begin{equation}
  C_A = base - r_k * w
  \end{equation}
  \begin{equation}
  r_k = \left\{ 
  \begin{array}{l l}
  low_k & \quad \text{se $k = 0$} \\
  r_{k-1} \times (|high_k-low_k|+1) + low_k & \quad \text{se $k \geq 1$}
  \end{array} \right.
  \end{equation}

#+END_EXPORT
\pause Exemplo com a declaração: *float cubo[3..5, -2..3, -4..10]*

* Possível solução (declaração)                                    :noexport:

Assumindo que tab é um ponteiro para a tabela de símbolos do escopo corrente.

decl \rightarrow T *id* [ L ] { ca = tab.desloc - L.r * T.w;
                    declara(id.lexval, T.w * L.n, T.tipo, ca);
                    tab.desloc += L.n; }

T    \rightarrow *float*      { T.w = 4; T.tipo = FLOAT; }

L    \rightarrow L_1 , D     { L.r = L_{1}.r * (D.n + 1) + D.lo;
                    L.n = L_{1}.n * D.n; }

L    \rightarrow D          { L.r = D.low;
                    L.n = D.n; } 

D    \rightarrow N_{1}..N_{2}     { D.low = N_{1}.val;
                    D.high = N_{2}.val;
                    D.n = abs(N_{2}.val - N_{1}.val); }

N    \rightarrow *num*        { N.val = atoi(num.lexval); }

* Esquema de Tradução (Acesso)
Gramática de acesso em arranjos multidimensionais
  | acesso | \rightarrow | *id* [ L ] |
  | L      | \rightarrow | L , D      |
  | L      | \rightarrow | D          |
  | D      | \rightarrow | *num*      |
\pause Esquema de tradução para calcular o endereço \\
  (repetindo o cálculo recursivo que permite obtê-lo)

#+BEGIN_EXPORT latex
  \begin{equation}
  endereco = C_A + d_k * w
  \end{equation}
  \begin{equation}
  d_k = \left\{ 
  \begin{array}{l l}
  i_k & \quad \text{se $k = 0$} \\
  d_{k-1} * |high_k-low_k| + i_k & \quad \text{se $k \geq 1$}
  \end{array} \right.
  \end{equation}
#+END_EXPORT
\pause Exemplo com o acesso: *cubo[4,-1,0]*

* Esquema de Tradução (Acesso e expr.)

Uma gramática de acesso em arranjos multidimensionais
  | acesso | \rightarrow | *id* [ L ] |
  | L      | \rightarrow | L , E    |
  | L      | \rightarrow | E        |
  | E      | \rightarrow | E + N    |
  | E      | \rightarrow | N        |
  | N      | \rightarrow | *num* \vert *id* |
\pause Esquema de tradução para calcular o endereço \\
  (repetindo o cálculo recursivo que permite obtê-lo)

#+BEGIN_EXPORT latex

  \begin{equation}
  endereco = C_A + d_k * w
  \end{equation}
  \begin{equation}
  d_k = \left\{ 
  \begin{array}{l l}
  i_k & \quad \text{se $k = 0$} \\
  d_{k-1} * |high_k-low_k| + i_k & \quad \text{se $k \geq 1$}
  \end{array} \right.
  \end{equation}
#+END_EXPORT
\pause Exemplo com o acesso: *cubo[a+b,c+d,e+4]*
* Possível solução (acesso com expressões)                         :noexport:
** Funções auxiliares

- char *geraTemp() \to função que gera um temporário
- char *tac(char *format, ...) \to função que gera uma instrução
- int tamDim(char *nome, int dim) \to retorna o tamanho da dimensão
- int obtemW (char *nome) \to retorna o tamanho do dado w
- int obtemCA (char *nome) \to retorna a constante CA

** Operadores especiais

- || \to indica concatenação

** Dígitos ao lado dos não terminais

- Somente para diferenciar os não-terminais. Exemplo:

#+BEGIN_EXAMPLE
L      \rightarrow L1 , E { ... L1.atributo L.atributo } 
#+END_EXAMPLE

** Variáveis globais auxiliares

- ident \to Identificador corrente no reconhecimento de um acesso
- tab \to Aponta para a tabela de símbolos do escopo corrente

** Esquema de tradução

E -> acesso {
             E.temp = geraTemp();
             E.code = acesso.code ||
                 tac("load acesso.temp => E.temp"); }

acesso \rightarrow V [ L ]   { 
                w = obtemW (ident);
                ca = obtemCA (ident);
                x = geraTemp();
                acesso.temp = geraTemp();
                acesso.code = L.code ||
                          tac("mult L.temp w => x") ||
                          tac("add x ca => acesso.temp"); }

    ident = NULL; }
V      \to *id*        { ident = id.lexval; }

L      \rightarrow L1 , E     { L.dim = L1.dim + 1;
                      x = geraTemp();
                      t = tamDim(ident, L.dim)
                      L.temp = geraTemp();
                      L.code = L1.code || E.code ||
                                  tac("mult L1.temp t => x") ||
                                  tac("add x E.temp => L.temp"); }

L      \rightarrow E         {  L.temp = E.temp;
                      L.code = E.code;
                      L.dim = 0; }

E      \rightarrow E1 + N     { E.temp = geraTemp();
                      E.code = E1.code || N.code ||
                               tac("add E1.temp N.temp => E.temp"); }
E      \rightarrow N         {  E.temp = N.temp;
                      E.code = N.code; }
N      \to *id*        { e = endereco(tab, id.lexval);
                     N.temp = geraTemp();
                     N.code = tac("load e => N.temp"); }
