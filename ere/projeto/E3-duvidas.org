# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+TITLE: Dúvidas da E3 do Projeto de Compilador
#+Author: Lucas Mello Schnorr
#+Date: schnorr@inf.ufrgs.br
#+Language: pt-br

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt, a4paper]
#+LATEX_HEADER: \input{org-babel.tex}

#+OPTIONS: toc:nil title:nil
#+STARTUP: overview indent
#+TAGS: Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

* E3 2020/2
** TODO 2021-03-03 D0
*** Pergunta #1

Prezado professor, podemos utilizar c++ no trabalho, ao invés de C?
Precisaríamos mudar o main.c para main.cpp, mas isto facilitaria para
a construção da árvore, pois ficaria mais simples utilizar vector, do
c++, para implementar uma árvore com um número arbitrário de filhos em
cada nó. Podemos fazer esta alteração?

R: Pode sim (usar C++), mas não vejo a necessidade de mudar de main.c
para main.cpp.  Implemente as funções em arquivos separados, cpp, que
são chamadas pelo código em C normal como está no main.c.
*** Pergunta #2.1

1) Precisamos colocar tipo nos tokens? Por exemplo: %token<valorReal>
   TK_LIT_FLOAT, ou somente a declaração do valor_lexico é suficiente? Se
   precisamos, temos como reaproveitar as definições do valor_lexico?
   Como faríamos isso?

R: Somente a declaração do valor léxico é suficiente, e recomendada de
acordo com a especificação. Nota que somente assim poderemos ter
acesso a uma estrutura genérica que poderá ser tratada independente de
qual é o valor do token por trás. Esse valor do token não será
perdido, temos descritores dentro da estrutura valor léxico que serão
responsáveis por diferenciar os tipos de literais, por exemplo.

*** Pergunta #2.2

2) Qual o tipo de dado de cada elemento da arvore? Seria a estrutura
   que contém número da linha, tipo e valor?

R: Cada nó da árvore deve ser de um tipo estrutura de dados definida
pelo grupo. Tipicamente, usa-se uma estrutura de árvore genérica
n-ária com um campo de usuário, onde nesse campo de usuário o grupo
poderá adicionar informações relativas à AST (tipo do nó, etc).

*** Pergunta #2.3

3) Para construirmos a arvore, pensamos em duas funções:

    - Uma que cria e retorna uma folha e, se a arvore esta vazia,
      atribui à arvore esta folha

    - Uma que recebe dados e filhos, cria um nodo, insere mais um
      filho e coloca a arvore nesse filho, depois atribui à arvore
      este novo nodo

Isto está correto? É assim mesmo para construirmos a árvore?

R: Uma folha é um nó sem filhos, então acho improdutivo ter um nó tipo
folha e um nó tipo intermediário. Conforme descrito na Sec 2.2, acho
que é importante ter funções de criação de nós e adição de filhos. A
construção da árvore em si é feita através das regras do bison. Um
exemplo, como criar a AST para a regra abaixo:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um nó da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Perceba o uso de $1 e $3 conforme vimos no video bison parte 2.  No
exemplo acima, apenas duas funções foram necessárias (~ast_create~ e
~ast_add_child~). Fica a critério do grupo empregar funções mais
sofisticadas se preferirem.

*** Pergunta #3

 Para representarmos uma expressão ternária na árvore sintática
 abstrata, posso considerar apenas a interrogação (?) como pai e os
 três outros operandos como filhos, ignorando os dois pontos (:)?

R: Pode. Mas veja que na prática, a interrogação e os dois pontos são
um único operador. Inclusive, chamos a atenção para o que está
explicitado na Sec 2.4: "No caso do operador ternário, deve ser
utilizado o nome '?:'.", mas isso apenas na saída. A tua AST pode
conter o tipo que quiser, como ~AST_TERNARY~ ou algo assim.

*** Pergunta #4

 Estou com dificuldade de entender como funciona o processo de
 construção da árvore sintática quando há múltiplas linhas de
 código. Em especial, como fazemos a inserção de folhas e de nodos com
 filhos? Nodos folhas devem ser inseridas onde? Nodos com filhos devem
 tornar-se pais do resto da arvore ou seguir como filhos da raiz? Como
 sabemos qual nodo é pai dos nodos filho?

R: Recomendo fazer um programa completo escrito na nossa linguagem e
executar o nosso compilador da seguinte forma:

#+BEGIN_EXAMPLE
./etapa3 < arquivo_com_programa_com_multiplas_linhas
#+END_EXAMPLE

Para fazer a inserção de nós e filhos, deve-se empregar totalmente os
marcadores especiais do bison para isso, através da adição de código
no final de cada regra gramatical, pois é ele que irá decidir a ordem
que estes códigos serão criados. Por exemplo, para a regra gramatical
que envolve o reconhecimento sintático da soma binária:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um nó da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Neste caso acima, temos um nó intermediário de soma que tem dois
filhos. Nós criamos um novo nó da nossa AST, com o tipo ~AST_SUM~, e o
atribuímos para $$, que é o marcador especial do bison para se referir
a cabeça da produção gramatical. Em seguida, adicionamos dois filhos,
primeiro o filho $1 e depois o filho $3 que são respectivamente os
dois operandos E do corpo da produção. Veja que esses operandos são
também do não-terminal E, então podemos sem dúvida assumir que os nós
da AST deles já foram criados pela execução de código associado às
outras regras gramaticais (inclusive essa mesma).

*** Pergunta #5

 Para representar a árvore, pensamos numa estrutura onde um nodo
 indica um próximo irmão e um próximo filho, ou seja, é uma árvore
 cujos filhos são listas encadeadas. Isto é permitido?

R: Recomendo a leitura da Sec 2.2 da especificação. Em geral, eu não
recomendo esse tipo de estrutura onde os irmãos estão conectados pois
ela não é natural no contexto de uma AST. Não teremos relação diretas
entre irmãos, apenas entre pai e seus filhos. Se algo preciso ser
feito entre irmãos, é o pai que se ocupará.

* E3 2020/1
** DONE 2020-09-23 D0
*** Pergunta #1

... depois de ver os vídeos sobre o Bison e a especificação ...
... gostaria de validar se é de fato isso que deve ser feito;

Defini 3 estruturas de dados em um arquivo separado:

- Uma union em C com campos como "int inteiro", "float
  ~ponto_flutuante~", "char* nome", para guardar o valor dos tokens
  lidos

- Uma struct que guarda a linha de ocorrencia, valor (a union acima) e
  tipo do token (Aqueles usados nas outras etapas como ~TK_LIT_INT~,
  etc.)

- Struct para os nodos da AST que guarda uma variavel do tipo
  ~valor_lexico~ e ponteiros para os nodos filhos e nodos irmaos desse
  nodo

No arquivo parser.y defini uma union do bison:

#+BEGIN_EXAMPLE
%union {
   node_t* nodo;
   valor_lexico_t* valor_lexico;
}
#+END_EXAMPLE

e nas declarações de tokens usei construções como

#+BEGIN_EXAMPLE
%token <valor_lexico->valor.inteiro> TK_LIT_INT
%type <nodo> operador_binario
#+END_EXAMPLE

É desta forma que devem ser organizados estes dados, ou estou fazendo
algum erro/redundância?

*** Pergunta #2

... não me parece claro como, no arquivo parser.y, teremos acesso à
variável "arvore" declarada no arquivo main.c, para que possamos
construí-la usando as ações do parser. Ela não deveria ser passada
para a função yyparse() de alguma forma?

** DONE 2020-09-23 Nota
- Falar sobre a especificação
  - Nó ~return~ da AST tem um filho, que é uma expressão
** DONE 2020-09-25 D1
*** Pergunta #1

Estamos tentando seguir a especificação e tentando ir de acordo com os
comentários no primeiro vídeo de dúvida para essa etapa, e criamos uma
struct da seguinte forma:

#+BEGIN_EXAMPLE
struct valor_lexico_t {
    int linha;
    union {
        int val_int;
        float val_float;
        char *val_str;
        char val_char;
    } valor;
};
#+END_EXAMPLE


Se declaramos ela em outro arquivo ou na parte de código C no arquivo
~parser.y~, precisamos, no ~%union~, definir ela da seguinte forma
"~valor_lexico_t *valor_lexico;~" (com ponteiro), mas isso está causando
segmentation fault sempre que tentamos adicionar algum valor nela no
~scanner.l~.

A adição sendo feita da seguinte forma:
"~yylval.valor_lexico->valor.val_int = atoi(yytext);~"

Porém, fazendo a declaração dessa estrutura da forma:

#+BEGIN_EXAMPLE
%code requires {
    // struct acima
}
#+END_EXAMPLE

conseguimos só definir o ~valor_lexico~ na union (sem ponteiro) e os
erros de segmentation param. Está certo deixar assim?

*** Pergunta #2

Não entendi como deve ser o campo "tipo do token" para a estrutura
~valor_lexico~. Devemos pegar os próprios tokens, (e.g. ~TK_LIT_TRUE~,
~TK_IDENTIFICADOR~) e colocar em um campo tipo int?

*** Pergunta #3

Você pede pra que os valores dos tokens sejam tratados de forma
correta em relação ao seu tipo, int como inteiro, caractere como
char.., mas tem um caso que queria saber como tratar. Na etapa 1
permitimos char no formato '\t', por exemplo, mas não sabemos agora
como transformar o conteúdo do ~yytext~ em 1 único char, quando houver
esse caso.

*** Pergunta #3

... como nos casos do char, genericamente seria apenas 1
caracter, ainda precisaríamos passar o ~yytext~ pelo ~strdup~? ele retorna
uma cadeia de caracteres, mas se pegássemos o conteúdo direto de
~yytext[1]~ já teríamos o valor dele, já sem as aspas.

** DONE 2020-09-29 D2
*** Dúvida #1

É possível acessar a variável yylval de um arquivo .h? Tentei usar o
comando extern, mas sempre ocorre algum erro na compilação.

*** Dúvida #2

Na seção 2.3, item 1, é dito que as declarações de funções devem ter
dois filhos: O primeiro comando e a próxima função.

1. Isto significa, então, que não devemos salvar a assinatura da
   função (os parâmetros que pode receber) como seus filhos?

2. Da mesma forma, não precisamos, então, salvar a declaração de
   variáveis globais na AST, visto que as funções apontam apenas para
   a próxima função?

3. Também relacionado a variáveis, nas variáveis locais precisamos
   colocar na AST apenas aquelas que são inicializadas (e.x. int x <=
   5;) e ignorar aquelas que não são (e.x. int x;)?

*** Dúvida #3

1. Na parte que fala sobre a exportação (impressão) da Árvore, você
   não fala nada sobre os comandos de "input" e "output". Não devemos
   printar eles?

   Na parte de chamar uma função, devemos printar cada parametro sendo
   passado?
   
   e se sim, como que fazemos a impressao deles na tela (indenficamos
   que serão separados por vírgula ou algo assim) ?

*** Dúvida #4

2. Na parte de montar a arvore, diz que não devemos colocar o bloco de
   comandos como um comando simples na arvore (2.3 - item 4.). Isso
   significa que iremos ignorar essa parte completamente?

*** Dúvida #5

3. Uma dúvida em relação a montagem da ast, por exemplo na criação de
   um nodo para a declaração de função, na especificação diz que deve
   ter pelo menos dois filhos (primeiro comando e a próxima
   função).

   Sobre isso, estamos criando um nodo de função que tem só um filho
   (sendo a primeiro comando), mas tem um nodo acima que aponta para
   essa declaração e depois para a próxima função. Queria entender se
   está correto fazer desta maneira, e se tem alguma implicação na
   parte de exportar a árvore (se teria problema em relação aos
   ponteiros na correção).

*** Dúvida #6

4. Na associação dos tokens no yylval, pensando nos caracteres
   especiais, não entendi como fazemos a relação deles com os valores
   do parser, sendo que no parser definimos esses símbolos ('+' e '-')
   manualmente nas expressões.

*** Dúvida #7

Acho que tinha me confundido nessa parte do chamar a função.

Nós vamos imprimir toda a estrutura da árvore em ponteiros (com suas
relações) e depois vamos identificá-los com os labels, certo?

Então nesse caso da chamada de função teremos o ponteiro da chamada e
depois x outros ponteiros que serão os parâmetros sendo passados? 

*** Dúvida #8

A impressão do "proximo" de um comando é feita da mesma forma que para
um filho?

*** Dúvida #9

Gostaria de pedir também se tens um exemplo um pouco maior de saída?
Algumas coisas parecem um pouco abstratas e poder ter uma base pra
compararmos nossa execução seria de grande ajuda.

#+BEGIN_SRC dot :tangle exemplo.dot
digraph {
  0xAA -> 0xBB;
  0xAA [ label = "func" ];
  0xBB [ label = "func2" ];
}
#+END_SRC

#+begin_src shell :results output
dot exemplo.dot -Tpdf -o exemplo.pdf
#+end_src
** DONE 2020-09-30 D3
*** Dúvida #5

Para mim, a questão do input e output ficou mais confusa após ter sido
dito que não é necessário imprimir o nó desses comandos se a
especificação não diz nada a respeito. Mas a especificação diz que
eles devem ter pelo menos um filho: a variável a ser lida ou
escrita. Gostaria de saber se esses comandos não devem mais fazer
parte da árvore ou não.

Resposta: output e input devem fazer parte da AST!
- Ver Dúvida #1 abaixo

Acredito que a pergunta anterior sobre isso se referia à ausência de
labels para esses comandos na especificação. Meu pensamento inicial é
que seriam "input" e "output", da mesma forma que return, break e
continue.

Anotação Prof.
- Ver "Dúvida #3"

*** Dúvida #1

Queria só confirmar sobre a exportação para os comandos "input" e
"output". No vídeo de dúvidas anterior você disse que como não é
falado no enunciado sobre a exportação deles não precisamos
trata-los. 

Resposta Prof.: Sim, precisamos tratá-los.

Quando diz que "não precisamos", ainda seria válido exportar eles?

Resposta Prof.: Totalmente válido!

Como fazemos a construção deles na árvore seria mais simples exportar
junto, especialmente na impressão da estrutura com os ponteiros dos
nodos.

--

Resposta Prof.:

- Da E2: Para entrada de dados, o comando tem a palavra reservada
  =input=, seguida de um identificador.  O comando de saída é
  identificado pela palavra reservada =output=, seguida de um
  identificador ou de um literal.

- Então, na E3:
  - Nó da AST =input= (label "input") tem pelo menos um filho
    - Um nó identificador
  - Nó da AST ~output~ (label "output") tem pelo menos um filho
    - Um nó identificador OU um nó literal

*** Dúvida #2 / Compartilhamento

"Script python para converter saída para o formato esperado pelo dot"

Google "Graphviz dot file format"

Boa noite professor, nós do grupo J fizemos um pequeno script que faz
a "tradução" para o formato que o dot espera. Isso facilita bastante a
correção das saídas. Sabemos que é um código bem simples, mas pensamos
que pode ajudar outros grupos. Envio o código em anexo, para que o
senhor disponibilize caso ache interessante.

Para utilizar basta rodar a etapa3 e direcionar a saída para um
arquivo (e.g. out.txt)::

#+begin_src shell :results output
python txt_to_diag.py out.txt diag.dot
dot diag.dot -Tpng > diag.png
#+end_src

Um detalhe é que utilizando os endereços originais o dot não
funcionou, então mudamos os nomes para n0, n1, n2 ... nN.

O grupo não garante corretude e adverte para usar com suas contas e
riscos 😅

*** Dúvida #3

1. Como mudamos o scanner da etapa1 para deixar os inteiros apenas
   como "positivos sem sinal", já que seria necessário na etapa
   anterior, queria saber se um inteiro -10, pode ser montado na
   arvore como uma expressão unária '-' que tem o filho "int 10",

   +ou se é necessário tentar "conectar" o int com o sinal em um caso+
   +desse tipo, deixando um nodo da arvore apenas com "-10".+

*** Dúvida #4

Uma dúvida (ou mais uma curiosidade) sobre a liberação de memória. Na
avaliação com o valgrind, precisamos apenas garantir que não haverá
leak de memória nos casos com sintaxe corretos. Testando o nosso
programa com um caso incorreto está dando leak, o que acredito que é o
esperado já que não estamos fazendo nenhum tratamento em passos
intermediários da construção (como a ast não vai ser montada
completamente, fazendo a ligação entre nodos ...).

Queria saber como que seria uma forma de corrigir isso? (armazenar
passos intermediários da arvore e mandar liberar explicitamente em
casos de erro?)

Como que compiladores costumam abordar isso?

*** Dúvida #6

Se alguma expressão do for possuir o operador unário interrogação (?)
ou o ternário (?:), poderia isso gerar problemas de precedência não
contemplados pelas regras de precedência da linguagem C? Se sim, como
devemos resolver esses problemas?
