# -*- coding: utf-8 -*-
# -*- mode: org -*-

#+TITLE: Dúvidas da E3 do Projeto de Compilador
#+Author: Lucas Mello Schnorr
#+Date: schnorr@inf.ufrgs.br
#+Language: pt-br

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt, a4paper]
#+LATEX_HEADER: \input{org-babel.tex}

#+OPTIONS: toc:nil title:nil
#+STARTUP: overview indent
#+TAGS: Lucas(L) noexport(n) deprecated(d)
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

* E3 2020/2
** TODO 2021-03-03 D0
*** Pergunta #1

Prezado professor, podemos utilizar c++ no trabalho, ao invés de C?
Precisaríamos mudar o main.c para main.cpp, mas isto facilitaria para
a construção da árvore, pois ficaria mais simples utilizar vector, do
c++, para implementar uma árvore com um número arbitrário de filhos em
cada nó. Podemos fazer esta alteração?

R: Pode sim (usar C++), mas não vejo a necessidade de mudar de main.c
para main.cpp.  Implemente as funções em arquivos separados, cpp, que
são chamadas pelo código em C normal como está no main.c.
*** Pergunta #2.1

1) Precisamos colocar tipo nos tokens? Por exemplo: ~%token<valorReal>~
   ~TK_LIT_FLOAT~, ou somente a declaração do ~valor_lexico~ é suficiente?
   Se precisamos, temos como reaproveitar as definições do
   ~valor_lexico~?  Como faríamos isso?

R: Somente a declaração do valor léxico é suficiente, e recomendada de
acordo com a especificação. Nota que somente assim poderemos ter
acesso a uma estrutura genérica que poderá ser tratada independente de
qual é o valor do token por trás. Esse valor do token não será
perdido, temos descritores dentro da estrutura valor léxico que serão
responsáveis por diferenciar os tipos de literais, por exemplo.

*** Pergunta #2.2

2) Qual o tipo de dado de cada elemento da arvore? Seria a estrutura
   que contém número da linha, tipo e valor?

R: Cada nó da árvore deve ser de um tipo estrutura de dados definida
pelo grupo. Tipicamente, usa-se uma estrutura de árvore genérica
n-ária com um campo de usuário, onde nesse campo de usuário o grupo
poderá adicionar informações relativas à AST (tipo do nó, etc).

*** Pergunta #2.3

3) Para construirmos a arvore, pensamos em duas funções:

    - Uma que cria e retorna uma folha e, se a arvore esta vazia,
      atribui à arvore esta folha

    - Uma que recebe dados e filhos, cria um nodo, insere mais um
      filho e coloca a arvore nesse filho, depois atribui à arvore
      este novo nodo

Isto está correto? É assim mesmo para construirmos a árvore?

R: Uma folha é um nó sem filhos, então acho improdutivo ter um nó tipo
folha e um nó tipo intermediário. Conforme descrito na Sec 2.2, acho
que é importante ter funções de criação de nós e adição de filhos. A
construção da árvore em si é feita através das regras do bison. Um
exemplo, como criar a AST para a regra abaixo:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um nó da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Perceba o uso de $1 e $3 conforme vimos no video bison parte 2.  No
exemplo acima, apenas duas funções foram necessárias (~ast_create~ e
~ast_add_child~). Fica a critério do grupo empregar funções mais
sofisticadas se preferirem.

*** Pergunta #3

 Para representarmos uma expressão ternária na árvore sintática
 abstrata, posso considerar apenas a interrogação (?) como pai e os
 três outros operandos como filhos, ignorando os dois pontos (:)?

R: Pode. Mas veja que na prática, a interrogação e os dois pontos são
um único operador. Inclusive, chamos a atenção para o que está
explicitado na Sec 2.4: "No caso do operador ternário, deve ser
utilizado o nome '?:'.", mas isso apenas na saída. A tua AST pode
conter o tipo que quiser, como ~AST_TERNARY~ ou algo assim.

*** Pergunta #4

 Estou com dificuldade de entender como funciona o processo de
 construção da árvore sintática quando há múltiplas linhas de
 código. Em especial, como fazemos a inserção de folhas e de nodos com
 filhos? Nodos folhas devem ser inseridas onde? Nodos com filhos devem
 tornar-se pais do resto da arvore ou seguir como filhos da raiz? Como
 sabemos qual nodo é pai dos nodos filho?

R: Recomendo fazer um programa completo escrito na nossa linguagem e
executar o nosso compilador da seguinte forma:

#+BEGIN_EXAMPLE
./etapa3 < arquivo_com_programa_com_multiplas_linhas
#+END_EXAMPLE

Para fazer a inserção de nós e filhos, deve-se empregar totalmente os
marcadores especiais do bison para isso, através da adição de código
no final de cada regra gramatical, pois é ele que irá decidir a ordem
que estes códigos serão criados. Por exemplo, para a regra gramatical
que envolve o reconhecimento sintático da soma binária:

#+BEGIN_EXAMPLE
E : E + E {
     $$ = ast_create(AST_SUM);  // Cria-se um nó da AST
     ast_add_child($$, $1);     // Adiciona seu primeiro filho
     ast_add_child($$, $3);     // Adiciona seu segundo filho
          };
#+END_EXAMPLE

Neste caso acima, temos um nó intermediário de soma que tem dois
filhos. Nós criamos um novo nó da nossa AST, com o tipo ~AST_SUM~, e o
atribuímos para $$, que é o marcador especial do bison para se referir
a cabeça da produção gramatical. Em seguida, adicionamos dois filhos,
primeiro o filho $1 e depois o filho $3 que são respectivamente os
dois operandos E do corpo da produção. Veja que esses operandos são
também do não-terminal E, então podemos sem dúvida assumir que os nós
da AST deles já foram criados pela execução de código associado às
outras regras gramaticais (inclusive essa mesma).

*** Pergunta #5

 Para representar a árvore, pensamos numa estrutura onde um nodo
 indica um próximo irmão e um próximo filho, ou seja, é uma árvore
 cujos filhos são listas encadeadas. Isto é permitido?

R: Recomendo a leitura da Sec 2.2 da especificação. Em geral, eu não
recomendo esse tipo de estrutura onde os irmãos estão conectados pois
ela não é natural no contexto de uma AST. Não teremos relação diretas
entre irmãos, apenas entre pai e seus filhos. Se algo preciso ser
feito entre irmãos, é o pai que se ocupará.

** TODO 2021-03-04 D1
*** Pergunta #1

Ficou claro para mim como devo lidar com ~$$~ nas produções, porém ainda
fiquei com uma dúvida: como fazemos para associar ~$$~ com a variável
void* arvore? Além disso, este void eu vou trocar para a minha struct
de nodo, certo? Ficará node* arvore, certo?​

R: A variável global ~arvore~ está definida no arquivo main.c e é
declarada como ~void*~, ou seja, ~arvore~ é um ponteiro para qualquer
coisa. É preferível que sua definição não mude. Para integrar o que
vocês farão com o comportamento imutável do main basta, no parser.y,
declarar a variável ~arvore~ como ~extern~, da seguinte forma:
#+BEGIN_EXAMPLE
extern void *arvore;
#+END_EXAMPLE
E depois, na primeira regra gramatical, ou seja, no primeiro
não-terminal a partir do qual tudo começa (tipicamente ~programa~),
deve-se definir o conteúdo da variável ~arvore~. Para evitar problemas
de compilação, etc, o grupo pode na atribuição forçar um cast. Esse
cast pode ser revertido na implementação das funções ~exporta~ e ~libera~,
cujo protótipo também não deve mudar. Como sabemos que é a mesma
variável que vai e vem, espera-se que não haverão problemas.

*** Pergunta #2

Eu e minha dupla não entendemos muito bem como devemos percorrer a
árvore para printá-la. O senhor poderia nos explicar melhor, por
favor?

R: O percorrimento da árvore deve ser de maneira recursiva. Para
atingir o efeito descrito na Sec 2.4 da especificação, deve-se, ao
chegar um determinado nó da árvore: 1) imprimir o endereço de memória
onde está a estrutura de dados (usando o %p como formatador para o
printf), seguido do seu label (consultem o formato na espec. da E2),
lembrando que o valor do label depende do tipo do nó; 2) para cada
filho (se houver), imprimir, para cada filho, o endereço de memória do
nó que estamos visitando seguido de uma vírgula seguido do endereço de
memória do filho. Feito essa listagem, basta recursivamente chamar a
função exporta para cada filho.

*** Pergunta #3

Na especificação da E3 está escrito que "Devem fazer parte da AST:
[...] Todos os comandos simples da linguagem, salvo o bloco de
comando" . MInha dúvida é: devemos simplesmente ignorar os blocos de
comando ao criar a AST?

R: Sim. Os blocos de comando e a declaração de variáveis sem
inicialização não devem fazer parte da AST. O bloco de comando
continua sendo importante para estruturar sintaticamente o programa,
ou seja, deve fazer parte da sintaxe como na E2.

*** Pergunta #4.1

estou confuso sobre o conteúdo do %union, mesmo tendo lido a seção 2.1
do enunciado várias vezes.

1) O enunciado diz que se sugere usar um campo de nome valor_lexico, e
   que o tipo dele é uma estrutura de dados com 3 campos: número da
   linha, tipo do token e valor do token. Estou com dificuldade de
   visualizar essa estrutura. Minha ideia inicial paraa fazer o %union
   foi essa:

#+BEGIN_EXAMPLE
%union
{
  VALUE *valor_lexico;
}

enum tokenType {
  specialChar, compoundOperator, identifier, literal
};

typedef struct value_struct
{
  int n_line;
  enum tokenType token_type;
  char* tokenValue;
} VALUE;
#+END_EXAMPLE

Teria alguma sugestão para fazer o %union de uma maneira mais simples
(por exemplo, sem o enum)?

----------

R: Nós vimos que a AST (veja aula N5 A0) tem nós intermediários e nós
folha, sendo que estas folhas são frequentemente os tokens obtidos na
entrada. Por essa razão, os tokens que integram as folhas na AST
(tipicamente identificadores e os literais) devem possuir um valor
pois eles integrarão parte da AST. Sendo esta a teoria e, por ser algo
muito frequente a ser implementado, o bison dá um suporte completo
para essa atividade, através do comando %union. Os campos dessa union
são os possíveis "valores" que podem estar associados aos tokens e aos
não-terminais. Em nosso projeto, o comando %union do bison normalmente
ter dois campos, como abaixo, sendo que o primeiro é o campo que será
utilizado para associar valor aos tokens, e o segundo é o campo que
será utilizado para criar a AST:
#+BEGIN_EXAMPLE
%union{
	struct valor_lexico_t* valor_lexico;
	struct nodo* no;
}
#+END_EXAMPLE
A ~struct valor_lexico_t*~ que, no teu código, é ~VALUE*~, tem sua
estrutura descrita na Sec 2.1 da espec. da E2. Chamo a atenção para o
segundo parágrafo do texto da especificação desta Sec 2.1, pois ali
descreve como o "valor do token" propriamente dito deve ser codificado
na estrutura. Veja que o ~tokenValue~ (que tu declaraste somente como
~char*~) deve ser uma ~union~ que comporta diferentes valores (int, float,
etc).

(segue na resposta da #4.2)

*** Pergunta #4.2

2) No exemplo de %union que tem nos slides da aula N3 A7, existe um
   campo chamado node* no. Ele precisa estar dentro do union também?
   Qual a relação entre o nodo e o %union?

----------

R: Então, dando prosseguimento à resposta da #4.1, temos dois campos
no %union: o primeiro para associar valor aos tokens, e o segundo para
associar valor aos não-terminais (que permitirão a criação da
estrutura da AST). No bison, o "tipo" default do valor dos tokens e
não-terminais é ~int~. Para alterar isso, precisamos efetivamente
declarar campos no %union e depois fazer o seguinte:
#+BEGIN_EXAMPLE
%token<valor_lexico> TK_IDENTIFICADOR
#+END_EXAMPLE
para dizer que o "tipo" de um token ~TK_IDENTIFICADOR~ é o campo
~valor_lexico~ da %union. E, fazer o seguinte:
#+BEGIN_EXAMPLE
%type<no> programa deffuncao
#+END_EXAMPLE
Para dizer que o "tipo" dos não-terminais programa e deffuncao,
portanto o valor associado a eles, é o campo ~no~ da %union. Feito isso,
nas regras gramaticais, tais como essa abaixo, podemos fazer uso dos
marcadores ~$$~, ~$1~, e ~$2~, sabendo que tais marcadores serão o tipo
%union declarado. Caso ~$1~ for um identificador podemos utilizar o
campo ~valor_lexico~. Caso ~$1~ for um não-terminal, saberemos que seu
valor é o que está no campo ~no~.

(segue na resposta da #4.3)

*** Pergunta #4.3

3) Também não entendi bem como funciona a yylval ao fazer a associação
   de um valor a um token. Se eu usasse a minha definição de union
   acima, seria assim a associação para, por exemplo, uma string?

#+BEGIN_EXAMPLE
{STRING} { yylval.valor_lexico.tokenValue = yytext; return TK_LIT_STRING; }
#+END_EXAMPLE

Se possível, gostaria de exemplos mais concretos em que yylval utiliza
valores contidos em %union e do armazenamento de yytext nele.

----

R: Do ponto de vista da gramática (do parser), nada mais precisa ser
feito além daquilo descrito até a resposta da #4.2. No entanto, do
ponto de vista do léxico (do scanner), precisamos garantir que quando
um ~TK_IDENTIFICADOR~ aparecer em uma regra gramatical, se a referirmos
através de $1, por exemplo, devemos acessar os dados de valor no campo
~valor_lexico~. Para que isso seja possível, precisamos usar, lá no
léxico, a variável global yylval. O tipo dessa variável é a union
declarada no comando %union do bison. Portanto, no teu código do
scanner, precisamos, imediatamente antes de retornar o token
reconhecido, alocar dinamicamente a estrutura de dados ~struct
valor_lexico_t~ (com malloc), inicializá-la corretamente, e atribuir o
ponteiro para o campo ~valor_lexico~. Essa alocação, inicialização e
atribuição pode ser feita da seguinte forma (inspirado pelo tipo que
tu estás usando):
#+BEGIN_EXAMPLE
{STRING} {
   VALUE* valor = malloc(1 * sizeof(VALUE)); // aloca a estrutura
   //TODO inicializar todos os campos da estrutura apontada por valor
   yylval.valor_lexico = valor; //atribuir para o yylval
   return TK_LIT_STRING;
}
#+END_EXAMPLE
Daí, lá na tua gramática, quando tu tiveres uma regra onde aparece um
~TK_LIT_STRING~, como:
#+BEGIN_EXAMPLE
decl_init: tipo TK_IDENTIFICADOR TK_OC_LT TK_LIT_STRING { 
#+END_EXAMPLE
Tu sabes que tu poderás recuperar o ponteiro do valor de ~TK_LIT_STRING~
através $4. Ou seja, $4 será o ~VALUE*~ que tu atribuíste lá no scanner
quando fizeste ~yylval.valor_lexico = valor~. Nota que nesse mesmo
exemplo, tu sabes que isso também é válido para ~TK_IDENTIFICADOR~ e
~TK_OC_LT~. No caso o não terminal ~tipo~ e ~decl_init~ serão do tipo ~no~ da
tua %union.

*** Pergunta #5

 A ação { $$ = NULL; } é consistente para o caso de produções que
 devem ser ignoradas?

R: Sim, tipicamente para produções cujo corpo é vazio.

*** Pergunta #6

Na função libera, posso adicionar mais um parâmetro? Queria deixá-la
assim: void libera (treeNode *root, bool primeiroUso); Isto é
permitido?

R: Não é permitido.

*** Pergunta #7

Para representarmos a árvore, ficamos confusos com uma questão:
devemos listar os endereços dos filhos nas linhas? Ou apenas o
endereço do nó?

No caso, uma linha válida seria assim:
0x55f8f45f23a0, 0x55f8f45f29100x55f8f45f23a0, 0x55f8f45f35900x55f8f45f2910 [label="<="];

Ou assim:
0x55f8f45f2810 [label="<="];
?

R: Na Sec 2.4 tem um exemplo completo sobre como exportar a
árvore. Poderias revisar e me dizer se aquilo que está lá escrito já
resolve a tua dúvida?

** 2021-03-07 D2
*** Dúvida #1

Eu reli a seção 2.4 mas minha dúvida permanece. Peço desculpas pois
pode ser que seja falha de interpretação minha, mas queria confirmar
com o senhor pois parte da correção é automática, então eu e minha
dupla precisamos ter certeza do formato exato da saída. O senhor
primeiro dá um exemplo de saída CSV válida onde uma linha pode conter
múltiplos endereços de memória (onde, em cada linha, há o endereço do
nó e o endereço dos filhos do nó), mas abaixo o senhor dá um exemplo
onde cada linha possui apenas um endereço de memória. Fiquei com
dúvida se, numa linha onde vamos representar um nó que possua filhos,
o correto seja:

a) Nessa linha imprimir o endereço do nó, seguido pelos endereços dos
filhos e, por fim, o label do nó

b) Nessa linha imprimir apenas o endereço do nó seguido pelo seu label

c) Nessa linha, imprimir o endereço do nó e o label do nó, seguido
pelo endereço dos filhos e label dos filhos

----

R: No exemplo fornecido na especificação da E3 (Sec 2.4), a linha deve
conter apenas dois endereços de memória (pai, filho). Se um pai tiver
mais de um filho, então haverá uma linha para cada relação pai, filho,
conforme o exemplo fornecido. Então, nenhuma das alternativas a), b),
e c) está correta. 

R: Retomando, existem dois tipos de linha:

1/ Linhas que registram a relação entre dois nós da árvore (são
aquelas linhas que tem dois endereços separados por vírgula)

2/ Linhas que registram o nome do nó da árvore (são aquelas linhas que
tem o campo label)

Teve uma pergunta sobre isso, e acabo de falar sobre isso no video E3
D0 D1, mas tu podes olhar diretamente a Pergunta #2 do E3 D1. Então,
respondendo tua pergunta diretamente, a opção é nenhuma das
alternativas. A resposta seria:

d) Nessa linha, imprimir o endereço do nó, seguido pelo endereço de um
dos filhos. Para representar as relações de um pai com todos os seus
filhos, tu precisarás de uma linha para cada filho, como está na
especificação. Todas essas linhas são do tipo 1/ (descrito
acima). Restam as linhas do tipo /2, uma para cada nó da árvore.
*** Dúvida #2.1

obrigado pelas respostas, elas nos ajudaram a entender melhor o que
devemos fazer. Mas ainda temos algumas dúvidas:

1) No caso do literal, de que forma devo armazenar o tipo do literal?
   Posso fazer isso dentro do enum que criei para os tipos do token?
   Assim:

#+BEGIN_EXAMPLE
typedef enum {
  specialChar, compoundOperator, identifier, lit_int, lit_float, lit_bool, lit_char, lit_string  // em vez de ser só "literal", ter uma opção para cada tipo
} tipoToken;
#+END_EXAMPLE

-----

R: Esse enum guarda apenas o tipo, não o valor. Um literal inteiro tem
que ser guardada em uma variável do tipo int, um literal
ponto-flutuante em um float, um caractere em um char, uma string em um
char*, um booleano em um int ou bool (se quiseres fazer um
typedef). Como um literal pode ser só de um tipo a cada vez, recomendo
colocar todos essas variáveis dentro de uma union, com uma variável
auxiliar para que tu registres qual é o tipo. A enum tu chamaste de
"tipoToken", e um tipo de token ou é specialChar, compoundOperator,
identifier, literal. Isso está no primeiro parágrafo da Sec 2.1.
Depois, tu teria um outro campo com o valor propriamente dito para
diferenciar entre os tipos de literais. Isso está no segundo parágrafo
da Sec 2.1.

*** Dúvida #2.2

2) Sobre exemplo de yylval que colocaste na resposta da minha pergunta
   3, devo fazer o mesmo para todos os tokens contidos no scanner.l
   (exceto palavras reservadas)? Por exemplo, no token ';':

#+BEGIN_EXAMPLE
";" {
  valor_lexico_t* valor = malloc(1*sizeof(valor_lexico_t));
  valor->n_linha = get_line_number();
  valor->type = specialChar;
  valor->val.s = strdup(yytext);
  yylval.valor_lexico = valor;
  return 59;
}
#+END_EXAMPLE

-----

R: Não vejo necessidade de criar um valor para cada token reconhecido
pelo léxico. Um exemplo é esse do ";", pois o "valor" desse
ponto-e-vírgula não será utilizado para nada. Veja resposta da dúvida
seguinte. Ah, e um outro comentário. Troque o "return 59" por "return
yytext[0]". Teu código ficará mais legível.

*** Dúvida #2.3

3) Sobre o nodo da AST: quais são os dados essenciais que devem estar
   contidos no nodo? Sei que o valor do token (ponteiro do tipo
   ~valor_lexico_t~) e um ponteiro para os nodos filhos devem fazer
   parte do struct do nodo, mas preciso armazenar algo mais?

-----

R: Com certeza precisa armazenar algo mais. Além dos ponteiros para os
filhos do nó e também do valor do token (ponteiro para o
~valor_lexico_t~, somente quando realmente necessário pois muitos nós
intermediários não são tokens), precisarás também guardar, pelo menos,
o tipo do nó da AST. Se é um IF, precisas guardar algo como ~AST_IF~. Se
é um WHILE, precisas guardar algo como ~AST_WHILE~. Se for um
identificador, será ~AST_IDENTIFICADOR~. Se for um literal, será um
~AST_LITERAL~, e assim por diante. Para os nós da AST cujo token tem
pouca utilidade (construções de fluxo de controle, por exemplo), o
valor deles pode ser NULL. De maneira ampla, o valor do token só é
realmente necessário quando temos identificadores e literais.

* E3 2020/1
** DONE 2020-09-23 D0
*** Pergunta #1

... depois de ver os vídeos sobre o Bison e a especificação ...
... gostaria de validar se é de fato isso que deve ser feito;

Defini 3 estruturas de dados em um arquivo separado:

- Uma union em C com campos como "int inteiro", "float
  ~ponto_flutuante~", "char* nome", para guardar o valor dos tokens
  lidos

- Uma struct que guarda a linha de ocorrencia, valor (a union acima) e
  tipo do token (Aqueles usados nas outras etapas como ~TK_LIT_INT~,
  etc.)

- Struct para os nodos da AST que guarda uma variavel do tipo
  ~valor_lexico~ e ponteiros para os nodos filhos e nodos irmaos desse
  nodo

No arquivo parser.y defini uma union do bison:

#+BEGIN_EXAMPLE
%union {
   node_t* nodo;
   valor_lexico_t* valor_lexico;
}
#+END_EXAMPLE

e nas declarações de tokens usei construções como

#+BEGIN_EXAMPLE
%token <valor_lexico->valor.inteiro> TK_LIT_INT
%type <nodo> operador_binario
#+END_EXAMPLE

É desta forma que devem ser organizados estes dados, ou estou fazendo
algum erro/redundância?

*** Pergunta #2

... não me parece claro como, no arquivo parser.y, teremos acesso à
variável "arvore" declarada no arquivo main.c, para que possamos
construí-la usando as ações do parser. Ela não deveria ser passada
para a função yyparse() de alguma forma?

** DONE 2020-09-23 Nota
- Falar sobre a especificação
  - Nó ~return~ da AST tem um filho, que é uma expressão
** DONE 2020-09-25 D1
*** Pergunta #1

Estamos tentando seguir a especificação e tentando ir de acordo com os
comentários no primeiro vídeo de dúvida para essa etapa, e criamos uma
struct da seguinte forma:

#+BEGIN_EXAMPLE
struct valor_lexico_t {
    int linha;
    union {
        int val_int;
        float val_float;
        char *val_str;
        char val_char;
    } valor;
};
#+END_EXAMPLE


Se declaramos ela em outro arquivo ou na parte de código C no arquivo
~parser.y~, precisamos, no ~%union~, definir ela da seguinte forma
"~valor_lexico_t *valor_lexico;~" (com ponteiro), mas isso está causando
segmentation fault sempre que tentamos adicionar algum valor nela no
~scanner.l~.

A adição sendo feita da seguinte forma:
"~yylval.valor_lexico->valor.val_int = atoi(yytext);~"

Porém, fazendo a declaração dessa estrutura da forma:

#+BEGIN_EXAMPLE
%code requires {
    // struct acima
}
#+END_EXAMPLE

conseguimos só definir o ~valor_lexico~ na union (sem ponteiro) e os
erros de segmentation param. Está certo deixar assim?

*** Pergunta #2

Não entendi como deve ser o campo "tipo do token" para a estrutura
~valor_lexico~. Devemos pegar os próprios tokens, (e.g. ~TK_LIT_TRUE~,
~TK_IDENTIFICADOR~) e colocar em um campo tipo int?

*** Pergunta #3

Você pede pra que os valores dos tokens sejam tratados de forma
correta em relação ao seu tipo, int como inteiro, caractere como
char.., mas tem um caso que queria saber como tratar. Na etapa 1
permitimos char no formato '\t', por exemplo, mas não sabemos agora
como transformar o conteúdo do ~yytext~ em 1 único char, quando houver
esse caso.

*** Pergunta #3

... como nos casos do char, genericamente seria apenas 1
caracter, ainda precisaríamos passar o ~yytext~ pelo ~strdup~? ele retorna
uma cadeia de caracteres, mas se pegássemos o conteúdo direto de
~yytext[1]~ já teríamos o valor dele, já sem as aspas.

** DONE 2020-09-29 D2
*** Dúvida #1

É possível acessar a variável yylval de um arquivo .h? Tentei usar o
comando extern, mas sempre ocorre algum erro na compilação.

*** Dúvida #2

Na seção 2.3, item 1, é dito que as declarações de funções devem ter
dois filhos: O primeiro comando e a próxima função.

1. Isto significa, então, que não devemos salvar a assinatura da
   função (os parâmetros que pode receber) como seus filhos?

2. Da mesma forma, não precisamos, então, salvar a declaração de
   variáveis globais na AST, visto que as funções apontam apenas para
   a próxima função?

3. Também relacionado a variáveis, nas variáveis locais precisamos
   colocar na AST apenas aquelas que são inicializadas (e.x. int x <=
   5;) e ignorar aquelas que não são (e.x. int x;)?

*** Dúvida #3

1. Na parte que fala sobre a exportação (impressão) da Árvore, você
   não fala nada sobre os comandos de "input" e "output". Não devemos
   printar eles?

   Na parte de chamar uma função, devemos printar cada parametro sendo
   passado?
   
   e se sim, como que fazemos a impressao deles na tela (indenficamos
   que serão separados por vírgula ou algo assim) ?

*** Dúvida #4

2. Na parte de montar a arvore, diz que não devemos colocar o bloco de
   comandos como um comando simples na arvore (2.3 - item 4.). Isso
   significa que iremos ignorar essa parte completamente?

*** Dúvida #5

3. Uma dúvida em relação a montagem da ast, por exemplo na criação de
   um nodo para a declaração de função, na especificação diz que deve
   ter pelo menos dois filhos (primeiro comando e a próxima
   função).

   Sobre isso, estamos criando um nodo de função que tem só um filho
   (sendo a primeiro comando), mas tem um nodo acima que aponta para
   essa declaração e depois para a próxima função. Queria entender se
   está correto fazer desta maneira, e se tem alguma implicação na
   parte de exportar a árvore (se teria problema em relação aos
   ponteiros na correção).

*** Dúvida #6

4. Na associação dos tokens no yylval, pensando nos caracteres
   especiais, não entendi como fazemos a relação deles com os valores
   do parser, sendo que no parser definimos esses símbolos ('+' e '-')
   manualmente nas expressões.

*** Dúvida #7

Acho que tinha me confundido nessa parte do chamar a função.

Nós vamos imprimir toda a estrutura da árvore em ponteiros (com suas
relações) e depois vamos identificá-los com os labels, certo?

Então nesse caso da chamada de função teremos o ponteiro da chamada e
depois x outros ponteiros que serão os parâmetros sendo passados? 

*** Dúvida #8

A impressão do "proximo" de um comando é feita da mesma forma que para
um filho?

*** Dúvida #9

Gostaria de pedir também se tens um exemplo um pouco maior de saída?
Algumas coisas parecem um pouco abstratas e poder ter uma base pra
compararmos nossa execução seria de grande ajuda.

#+BEGIN_SRC dot :tangle exemplo.dot
digraph {
  0xAA -> 0xBB;
  0xAA [ label = "func" ];
  0xBB [ label = "func2" ];
}
#+END_SRC

#+begin_src shell :results output
dot exemplo.dot -Tpdf -o exemplo.pdf
#+end_src
** DONE 2020-09-30 D3
*** Dúvida #5

Para mim, a questão do input e output ficou mais confusa após ter sido
dito que não é necessário imprimir o nó desses comandos se a
especificação não diz nada a respeito. Mas a especificação diz que
eles devem ter pelo menos um filho: a variável a ser lida ou
escrita. Gostaria de saber se esses comandos não devem mais fazer
parte da árvore ou não.

Resposta: output e input devem fazer parte da AST!
- Ver Dúvida #1 abaixo

Acredito que a pergunta anterior sobre isso se referia à ausência de
labels para esses comandos na especificação. Meu pensamento inicial é
que seriam "input" e "output", da mesma forma que return, break e
continue.

Anotação Prof.
- Ver "Dúvida #3"

*** Dúvida #1

Queria só confirmar sobre a exportação para os comandos "input" e
"output". No vídeo de dúvidas anterior você disse que como não é
falado no enunciado sobre a exportação deles não precisamos
trata-los. 

Resposta Prof.: Sim, precisamos tratá-los.

Quando diz que "não precisamos", ainda seria válido exportar eles?

Resposta Prof.: Totalmente válido!

Como fazemos a construção deles na árvore seria mais simples exportar
junto, especialmente na impressão da estrutura com os ponteiros dos
nodos.

--

Resposta Prof.:

- Da E2: Para entrada de dados, o comando tem a palavra reservada
  =input=, seguida de um identificador.  O comando de saída é
  identificado pela palavra reservada =output=, seguida de um
  identificador ou de um literal.

- Então, na E3:
  - Nó da AST =input= (label "input") tem pelo menos um filho
    - Um nó identificador
  - Nó da AST ~output~ (label "output") tem pelo menos um filho
    - Um nó identificador OU um nó literal

*** Dúvida #2 / Compartilhamento

"Script python para converter saída para o formato esperado pelo dot"

Google "Graphviz dot file format"

Boa noite professor, nós do grupo J fizemos um pequeno script que faz
a "tradução" para o formato que o dot espera. Isso facilita bastante a
correção das saídas. Sabemos que é um código bem simples, mas pensamos
que pode ajudar outros grupos. Envio o código em anexo, para que o
senhor disponibilize caso ache interessante.

Para utilizar basta rodar a etapa3 e direcionar a saída para um
arquivo (e.g. out.txt)::

#+begin_src shell :results output
python txt_to_diag.py out.txt diag.dot
dot diag.dot -Tpng > diag.png
#+end_src

Um detalhe é que utilizando os endereços originais o dot não
funcionou, então mudamos os nomes para n0, n1, n2 ... nN.

O grupo não garante corretude e adverte para usar com suas contas e
riscos 😅

*** Dúvida #3

1. Como mudamos o scanner da etapa1 para deixar os inteiros apenas
   como "positivos sem sinal", já que seria necessário na etapa
   anterior, queria saber se um inteiro -10, pode ser montado na
   arvore como uma expressão unária '-' que tem o filho "int 10",

   +ou se é necessário tentar "conectar" o int com o sinal em um caso+
   +desse tipo, deixando um nodo da arvore apenas com "-10".+

*** Dúvida #4

Uma dúvida (ou mais uma curiosidade) sobre a liberação de memória. Na
avaliação com o valgrind, precisamos apenas garantir que não haverá
leak de memória nos casos com sintaxe corretos. Testando o nosso
programa com um caso incorreto está dando leak, o que acredito que é o
esperado já que não estamos fazendo nenhum tratamento em passos
intermediários da construção (como a ast não vai ser montada
completamente, fazendo a ligação entre nodos ...).

Queria saber como que seria uma forma de corrigir isso? (armazenar
passos intermediários da arvore e mandar liberar explicitamente em
casos de erro?)

Como que compiladores costumam abordar isso?

*** Dúvida #6

Se alguma expressão do for possuir o operador unário interrogação (?)
ou o ternário (?:), poderia isso gerar problemas de precedência não
contemplados pelas regras de precedência da linguagem C? Se sim, como
devemos resolver esses problemas?
