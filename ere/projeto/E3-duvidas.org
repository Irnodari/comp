#+STARTUP: overview indent
#+TITLE: D√∫vidas da E3 do Projeto de Compilador

* E3 2020/2
** 2021-03-03
*** Pergunta #1

Prezado professor, podemos utilizar c++ no trabalho, ao inv√©s de C?
Precisar√≠amos mudar o main.c para main.cpp, mas isto facilitaria para
a constru√ß√£o da √°rvore, pois ficaria mais simples utilizar vector, do
c++, para implementar uma √°rvore com um n√∫mero arbitr√°rio de filhos em
cada n√≥. Podemos fazer esta altera√ß√£o?

R: Pode sim (usar C++), mas n√£o vejo a necessidade de mudar de main.c
para main.cpp.  Implemente as fun√ß√µes em arquivos separados, cpp, que
s√£o chamadas pelo c√≥digo em C normal como est√° no main.c.

* E3 2020/1
** DONE 2020-09-23 D0
*** Pergunta #1

... depois de ver os v√≠deos sobre o Bison e a especifica√ß√£o ...
... gostaria de validar se √© de fato isso que deve ser feito;

Defini 3 estruturas de dados em um arquivo separado:

- Uma union em C com campos como "int inteiro", "float
  ~ponto_flutuante~", "char* nome", para guardar o valor dos tokens
  lidos

- Uma struct que guarda a linha de ocorrencia, valor (a union acima) e
  tipo do token (Aqueles usados nas outras etapas como ~TK_LIT_INT~,
  etc.)

- Struct para os nodos da AST que guarda uma variavel do tipo
  ~valor_lexico~ e ponteiros para os nodos filhos e nodos irmaos desse
  nodo

No arquivo parser.y defini uma union do bison:

#+BEGIN_EXAMPLE
%union {
   node_t* nodo;
   valor_lexico_t* valor_lexico;
}
#+END_EXAMPLE

e nas declara√ß√µes de tokens usei constru√ß√µes como

#+BEGIN_EXAMPLE
%token <valor_lexico->valor.inteiro> TK_LIT_INT
%type <nodo> operador_binario
#+END_EXAMPLE

√â desta forma que devem ser organizados estes dados, ou estou fazendo
algum erro/redund√¢ncia?

*** Pergunta #2

... n√£o me parece claro como, no arquivo parser.y, teremos acesso √†
vari√°vel "arvore" declarada no arquivo main.c, para que possamos
constru√≠-la usando as a√ß√µes do parser. Ela n√£o deveria ser passada
para a fun√ß√£o yyparse() de alguma forma?

** DONE 2020-09-23 Nota
- Falar sobre a especifica√ß√£o
  - N√≥ ~return~ da AST tem um filho, que √© uma express√£o
** DONE 2020-09-25 D1
*** Pergunta #1

Estamos tentando seguir a especifica√ß√£o e tentando ir de acordo com os
coment√°rios no primeiro v√≠deo de d√∫vida para essa etapa, e criamos uma
struct da seguinte forma:

#+BEGIN_EXAMPLE
struct valor_lexico_t {
    int linha;
    union {
        int val_int;
        float val_float;
        char *val_str;
        char val_char;
    } valor;
};
#+END_EXAMPLE


Se declaramos ela em outro arquivo ou na parte de c√≥digo C no arquivo
~parser.y~, precisamos, no ~%union~, definir ela da seguinte forma
"~valor_lexico_t *valor_lexico;~" (com ponteiro), mas isso est√° causando
segmentation fault sempre que tentamos adicionar algum valor nela no
~scanner.l~.

A adi√ß√£o sendo feita da seguinte forma:
"~yylval.valor_lexico->valor.val_int = atoi(yytext);~"

Por√©m, fazendo a declara√ß√£o dessa estrutura da forma:

#+BEGIN_EXAMPLE
%code requires {
    // struct acima
}
#+END_EXAMPLE

conseguimos s√≥ definir o ~valor_lexico~ na union (sem ponteiro) e os
erros de segmentation param. Est√° certo deixar assim?

*** Pergunta #2

N√£o entendi como deve ser o campo "tipo do token" para a estrutura
~valor_lexico~. Devemos pegar os pr√≥prios tokens, (e.g. ~TK_LIT_TRUE~,
~TK_IDENTIFICADOR~) e colocar em um campo tipo int?

*** Pergunta #3

Voc√™ pede pra que os valores dos tokens sejam tratados de forma
correta em rela√ß√£o ao seu tipo, int como inteiro, caractere como
char.., mas tem um caso que queria saber como tratar. Na etapa 1
permitimos char no formato '\t', por exemplo, mas n√£o sabemos agora
como transformar o conte√∫do do ~yytext~ em 1 √∫nico char, quando houver
esse caso.

*** Pergunta #3

... como nos casos do char, genericamente seria apenas 1
caracter, ainda precisar√≠amos passar o ~yytext~ pelo ~strdup~? ele retorna
uma cadeia de caracteres, mas se peg√°ssemos o conte√∫do direto de
~yytext[1]~ j√° ter√≠amos o valor dele, j√° sem as aspas.

** DONE 2020-09-29 D2
*** D√∫vida #1

√â poss√≠vel acessar a vari√°vel yylval de um arquivo .h? Tentei usar o
comando extern, mas sempre ocorre algum erro na compila√ß√£o.

*** D√∫vida #2

Na se√ß√£o 2.3, item 1, √© dito que as declara√ß√µes de fun√ß√µes devem ter
dois filhos: O primeiro comando e a pr√≥xima fun√ß√£o.

1. Isto significa, ent√£o, que n√£o devemos salvar a assinatura da
   fun√ß√£o (os par√¢metros que pode receber) como seus filhos?

2. Da mesma forma, n√£o precisamos, ent√£o, salvar a declara√ß√£o de
   vari√°veis globais na AST, visto que as fun√ß√µes apontam apenas para
   a pr√≥xima fun√ß√£o?

3. Tamb√©m relacionado a vari√°veis, nas vari√°veis locais precisamos
   colocar na AST apenas aquelas que s√£o inicializadas (e.x. int x <=
   5;) e ignorar aquelas que n√£o s√£o (e.x. int x;)?

*** D√∫vida #3

1. Na parte que fala sobre a exporta√ß√£o (impress√£o) da √Årvore, voc√™
   n√£o fala nada sobre os comandos de "input" e "output". N√£o devemos
   printar eles?

   Na parte de chamar uma fun√ß√£o, devemos printar cada parametro sendo
   passado?
   
   e se sim, como que fazemos a impressao deles na tela (indenficamos
   que ser√£o separados por v√≠rgula ou algo assim) ?

*** D√∫vida #4

2. Na parte de montar a arvore, diz que n√£o devemos colocar o bloco de
   comandos como um comando simples na arvore (2.3 - item 4.). Isso
   significa que iremos ignorar essa parte completamente?

*** D√∫vida #5

3. Uma d√∫vida em rela√ß√£o a montagem da ast, por exemplo na cria√ß√£o de
   um nodo para a declara√ß√£o de fun√ß√£o, na especifica√ß√£o diz que deve
   ter pelo menos dois filhos (primeiro comando e a pr√≥xima
   fun√ß√£o).

   Sobre isso, estamos criando um nodo de fun√ß√£o que tem s√≥ um filho
   (sendo a primeiro comando), mas tem um nodo acima que aponta para
   essa declara√ß√£o e depois para a pr√≥xima fun√ß√£o. Queria entender se
   est√° correto fazer desta maneira, e se tem alguma implica√ß√£o na
   parte de exportar a √°rvore (se teria problema em rela√ß√£o aos
   ponteiros na corre√ß√£o).

*** D√∫vida #6

4. Na associa√ß√£o dos tokens no yylval, pensando nos caracteres
   especiais, n√£o entendi como fazemos a rela√ß√£o deles com os valores
   do parser, sendo que no parser definimos esses s√≠mbolos ('+' e '-')
   manualmente nas express√µes.

*** D√∫vida #7

Acho que tinha me confundido nessa parte do chamar a fun√ß√£o.

N√≥s vamos imprimir toda a estrutura da √°rvore em ponteiros (com suas
rela√ß√µes) e depois vamos identific√°-los com os labels, certo?

Ent√£o nesse caso da chamada de fun√ß√£o teremos o ponteiro da chamada e
depois x outros ponteiros que ser√£o os par√¢metros sendo passados? 

*** D√∫vida #8

A impress√£o do "proximo" de um comando √© feita da mesma forma que para
um filho?

*** D√∫vida #9

Gostaria de pedir tamb√©m se tens um exemplo um pouco maior de sa√≠da?
Algumas coisas parecem um pouco abstratas e poder ter uma base pra
compararmos nossa execu√ß√£o seria de grande ajuda.

#+BEGIN_SRC dot :tangle exemplo.dot
digraph {
  0xAA -> 0xBB;
  0xAA [ label = "func" ];
  0xBB [ label = "func2" ];
}
#+END_SRC

#+begin_src shell :results output
dot exemplo.dot -Tpdf -o exemplo.pdf
#+end_src
** DONE 2020-09-30 D3
*** D√∫vida #5

Para mim, a quest√£o do input e output ficou mais confusa ap√≥s ter sido
dito que n√£o √© necess√°rio imprimir o n√≥ desses comandos se a
especifica√ß√£o n√£o diz nada a respeito. Mas a especifica√ß√£o diz que
eles devem ter pelo menos um filho: a vari√°vel a ser lida ou
escrita. Gostaria de saber se esses comandos n√£o devem mais fazer
parte da √°rvore ou n√£o.

Resposta: output e input devem fazer parte da AST!
- Ver D√∫vida #1 abaixo

Acredito que a pergunta anterior sobre isso se referia √† aus√™ncia de
labels para esses comandos na especifica√ß√£o. Meu pensamento inicial √©
que seriam "input" e "output", da mesma forma que return, break e
continue.

Anota√ß√£o Prof.
- Ver "D√∫vida #3"

*** D√∫vida #1

Queria s√≥ confirmar sobre a exporta√ß√£o para os comandos "input" e
"output". No v√≠deo de d√∫vidas anterior voc√™ disse que como n√£o √©
falado no enunciado sobre a exporta√ß√£o deles n√£o precisamos
trata-los. 

Resposta Prof.: Sim, precisamos trat√°-los.

Quando diz que "n√£o precisamos", ainda seria v√°lido exportar eles?

Resposta Prof.: Totalmente v√°lido!

Como fazemos a constru√ß√£o deles na √°rvore seria mais simples exportar
junto, especialmente na impress√£o da estrutura com os ponteiros dos
nodos.

--

Resposta Prof.:

- Da E2: Para entrada de dados, o comando tem a palavra reservada
  =input=, seguida de um identificador.  O comando de sa√≠da √©
  identificado pela palavra reservada =output=, seguida de um
  identificador ou de um literal.

- Ent√£o, na E3:
  - N√≥ da AST =input= (label "input") tem pelo menos um filho
    - Um n√≥ identificador
  - N√≥ da AST ~output~ (label "output") tem pelo menos um filho
    - Um n√≥ identificador OU um n√≥ literal

*** D√∫vida #2 / Compartilhamento

"Script python para converter sa√≠da para o formato esperado pelo dot"

Google "Graphviz dot file format"

Boa noite professor, n√≥s do grupo J fizemos um pequeno script que faz
a "tradu√ß√£o" para o formato que o dot espera. Isso facilita bastante a
corre√ß√£o das sa√≠das. Sabemos que √© um c√≥digo bem simples, mas pensamos
que pode ajudar outros grupos. Envio o c√≥digo em anexo, para que o
senhor disponibilize caso ache interessante.

Para utilizar basta rodar a etapa3 e direcionar a sa√≠da para um
arquivo (e.g. out.txt)::

#+begin_src shell :results output
python txt_to_diag.py out.txt diag.dot
dot diag.dot -Tpng > diag.png
#+end_src

Um detalhe √© que utilizando os endere√ßos originais o dot n√£o
funcionou, ent√£o mudamos os nomes para n0, n1, n2 ... nN.

O grupo n√£o garante corretude e adverte para usar com suas contas e
riscos üòÖ

*** D√∫vida #3

1. Como mudamos o scanner da etapa1 para deixar os inteiros apenas
   como "positivos sem sinal", j√° que seria necess√°rio na etapa
   anterior, queria saber se um inteiro -10, pode ser montado na
   arvore como uma express√£o un√°ria '-' que tem o filho "int 10",

   +ou se √© necess√°rio tentar "conectar" o int com o sinal em um caso+
   +desse tipo, deixando um nodo da arvore apenas com "-10".+

*** D√∫vida #4

Uma d√∫vida (ou mais uma curiosidade) sobre a libera√ß√£o de mem√≥ria. Na
avalia√ß√£o com o valgrind, precisamos apenas garantir que n√£o haver√°
leak de mem√≥ria nos casos com sintaxe corretos. Testando o nosso
programa com um caso incorreto est√° dando leak, o que acredito que √© o
esperado j√° que n√£o estamos fazendo nenhum tratamento em passos
intermedi√°rios da constru√ß√£o (como a ast n√£o vai ser montada
completamente, fazendo a liga√ß√£o entre nodos ...).

Queria saber como que seria uma forma de corrigir isso? (armazenar
passos intermedi√°rios da arvore e mandar liberar explicitamente em
casos de erro?)

Como que compiladores costumam abordar isso?

*** D√∫vida #6

Se alguma express√£o do for possuir o operador un√°rio interroga√ß√£o (?)
ou o tern√°rio (?:), poderia isso gerar problemas de preced√™ncia n√£o
contemplados pelas regras de preced√™ncia da linguagem C? Se sim, como
devemos resolver esses problemas?
