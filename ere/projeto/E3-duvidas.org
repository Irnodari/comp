#+STARTUP: overview indent
#+TITLE: Dúvidas da E3 do Projeto de Compilador
* E3
** DONE 2020-09-23 D0
*** Pergunta #1

... depois de ver os vídeos sobre o Bison e a especificação ...
... gostaria de validar se é de fato isso que deve ser feito;

Defini 3 estruturas de dados em um arquivo separado:

- Uma union em C com campos como "int inteiro", "float
  ~ponto_flutuante~", "char* nome", para guardar o valor dos tokens
  lidos

- Uma struct que guarda a linha de ocorrencia, valor (a union acima) e
  tipo do token (Aqueles usados nas outras etapas como ~TK_LIT_INT~,
  etc.)

- Struct para os nodos da AST que guarda uma variavel do tipo
  ~valor_lexico~ e ponteiros para os nodos filhos e nodos irmaos desse
  nodo

No arquivo parser.y defini uma union do bison:

#+BEGIN_EXAMPLE
%union {
   node_t* nodo;
   valor_lexico_t* valor_lexico;
}
#+END_EXAMPLE

e nas declarações de tokens usei construções como

#+BEGIN_EXAMPLE
%token <valor_lexico->valor.inteiro> TK_LIT_INT
%type <nodo> operador_binario
#+END_EXAMPLE

É desta forma que devem ser organizados estes dados, ou estou fazendo
algum erro/redundância?

*** Pergunta #2

... não me parece claro como, no arquivo parser.y, teremos acesso à
variável "arvore" declarada no arquivo main.c, para que possamos
construí-la usando as ações do parser. Ela não deveria ser passada
para a função yyparse() de alguma forma?

** DONE 2020-09-23 Nota
- Falar sobre a especificação
  - Nó ~return~ da AST tem um filho, que é uma expressão
** DONE 2020-09-25 D1
*** Pergunta #1

Estamos tentando seguir a especificação e tentando ir de acordo com os
comentários no primeiro vídeo de dúvida para essa etapa, e criamos uma
struct da seguinte forma:

#+BEGIN_EXAMPLE
struct valor_lexico_t {
    int linha;
    union {
        int val_int;
        float val_float;
        char *val_str;
        char val_char;
    } valor;
};
#+END_EXAMPLE


Se declaramos ela em outro arquivo ou na parte de código C no arquivo
~parser.y~, precisamos, no ~%union~, definir ela da seguinte forma
"~valor_lexico_t *valor_lexico;~" (com ponteiro), mas isso está causando
segmentation fault sempre que tentamos adicionar algum valor nela no
~scanner.l~.

A adição sendo feita da seguinte forma:
"~yylval.valor_lexico->valor.val_int = atoi(yytext);~"

Porém, fazendo a declaração dessa estrutura da forma:

#+BEGIN_EXAMPLE
%code requires {
    // struct acima
}
#+END_EXAMPLE

conseguimos só definir o ~valor_lexico~ na union (sem ponteiro) e os
erros de segmentation param. Está certo deixar assim?

*** Pergunta #2

Não entendi como deve ser o campo "tipo do token" para a estrutura
~valor_lexico~. Devemos pegar os próprios tokens, (e.g. ~TK_LIT_TRUE~,
~TK_IDENTIFICADOR~) e colocar em um campo tipo int?

*** Pergunta #3

Você pede pra que os valores dos tokens sejam tratados de forma
correta em relação ao seu tipo, int como inteiro, caractere como
char.., mas tem um caso que queria saber como tratar. Na etapa 1
permitimos char no formato '\t', por exemplo, mas não sabemos agora
como transformar o conteúdo do ~yytext~ em 1 único char, quando houver
esse caso.

*** Pergunta #3

... como nos casos do char, genericamente seria apenas 1
caracter, ainda precisaríamos passar o ~yytext~ pelo ~strdup~? ele retorna
uma cadeia de caracteres, mas se pegássemos o conteúdo direto de
~yytext[1]~ já teríamos o valor dele, já sem as aspas.



** TODO 2020-09-29 D2
*** Dúvida #1

É possível acessar a variável yylval de um arquivo .h? Tentei usar o
comando extern, mas sempre ocorre algum erro na compilação.

*** Dúvida #2

Na seção 2.3, item 1, é dito que as declarações de funções devem ter
dois filhos: O primeiro comando e a próxima função.

1. Isto significa, então, que não devemos salvar a assinatura da
   função (os parâmetros que pode receber) como seus filhos?

2. Da mesma forma, não precisamos, então, salvar a declaração de
   variáveis globais na AST, visto que as funções apontam apenas para
   a próxima função?

3. Também relacionado a variáveis, nas variáveis locais precisamos
   colocar na AST apenas aquelas que são inicializadas (e.x. int x <=
   5;) e ignorar aquelas que não são (e.x. int x;)?

*** Dúvida #3

1. Na parte que fala sobre a exportação (impressão) da Árvore, você
   não fala nada sobre os comandos de "input" e "output". Não devemos
   printar eles?  Na parte de chamar uma função, devemos printar cada
   parametro sendo passado? e se sim, como que fazemos a impressao
   deles na tela (indenficamos que serão separados por vírgula ou algo
   assim) ?

*** Dúvida #4

2. Na parte de montar a arvore, diz que não devemos colocar o bloco de
   comandos como um comando simples na arvore (2.3 - item 4.). Isso
   significa que iremos ignorar essa parte completamente?

*** Dúvida #5

3. Uma dúvida em relação a montagem da ast, por exemplo na criação de
   um nodo para a declaração de função, na especificação diz que deve
   ter pelo menos dois filhos (primeiro comando e a próxima
   função). Sobre isso, estamos criando um nodo de função que tem só
   um filho (sendo a primeiro comando), mas tem um nodo acima que
   aponta para essa declaração e depois para a próxima função. Queria
   entender se está correto fazer desta maneira, e se tem alguma
   implicação na parte de exportar a árvore (se teria problema em
   relação aos ponteiros na correção).
*** Dúvida #6

4. Na associação dos tokens no yylval, pensando nos caracteres
   especiais, não entendi como fazemos a relação deles com os valores
   do parser, sendo que no parser definimos esses símbolos ('+' e '-')
   manualmente nas expressões.

*** Dúvida #7

Acho que tinha me confundido nessa parte do chamar a função.

Nós vamos imprimir toda a estrutura da árvore em ponteiros (com suas
relações) e depois vamos identificá-los com os labels, certo?

Então nesse caso da chamada de função teremos o ponteiro da chamada e
depois x outros ponteiros que serão os parâmetros sendo passados? 

*** Dúvida #8

A impressão do "proximo" de um comando é feita da mesma forma que para
um filho?

*** Dúvida #9

Gostaria de pedir também se tens um exemplo um pouco maior de saída?
Algumas coisas parecem um pouco abstratas e poder ter uma base pra
compararmos nossa execução seria de grande ajuda.
