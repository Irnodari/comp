#+STARTUP: overview indent
#+TITLE: Dúvidas da E4 do Projeto de Compilador

* E4 2020/2
** 2021-03-22 D0
*** Dúvida #1

1) Queria saber se faz sentido uma estrutura de dados para a tabela da
   seguinte forma. A tabela contém 2 coisas: 1) um struct Simbolo, que
   é composto da chave (de tipo char*), do conteúdo (struct com os
   campos ditos no enunciado) e de um ponteiro para o próximo símbolo
   da tabela/escopo; 2) um ponteiro para a próxima tabela. Essa
   implementação poderia causar problemas? Teria sugestões?

*** Dúvida #2

2) Dentro do conteúdo de um símbolo, qual seria a melhor forma de
   armazenar os argumentos da função e seus tipos?

*** Dúvida #3

3) Quando reconheço um identificador (por exemplo) no parser.y, devo
   percorrer todas as variáveis contidas no escopos global e local
   para verificar se ela já foi declarada? Senão devo criar um símbolo
   novo, com chave e conteúdo, para o identificador?

*** Dúvida #4

4) Qual a diferença entre o novo campo de tipo do nodo da AST e o
   campo de tipo que existe no conteúdo de um símbolo?

*** Dúvida #5

Tenho duas dúvidas sobre a etapa 4. A primeira é: ao implementar a
tabela de símbolos, podemos usar uma pilha para administrar os
diferentes escopos. No entanto, ao sairmos de um escopo devemos
remover o topo da pilha, e portanto a informação sobre as variáveis
declaradas ali será perdida. Essa informação deve ser salva para as
próximas etapas, ou ela só serve para detectar os erros implementados
nessa etapa? Se for para ser salva, onde devemos salvar as diferentes
tabelas? 

*** Dúvida #6

A segunda dúvida é a respeito dos blocos de comando aninhados. Cada
variável declarada dentro de um if, while ou for tem seu escopo
restrito a esse bloco? E devemos permitir a definição de um novo bloco
sem um comando de fluxo (por exemplo escrever algo como int main(){
bool exp1 = true; {bool exp1 = false; } } ?

*** Dúvida #7

Tenho uma dúvida referente á detectar novos blocos de comandos na
etapa 4. Por se tratar de um analisador ascendente, os identificadores
são adicionados à arvore antes dos blocos de comando serem
adicionados, portanto não sabemos qual é o escopo do identificador no
momento que ele é encontrado. Por não sabermos qual é o escopo, como
vou adicionar o identificador na tabela correta?

*** Dúvida #8
* E4 2020/1
** DONE 2020-10-06 D0
*** Dúvida #1

Estou agora refazendo as ações semânticas feitas na etapa 3, de
forma a criar as entradas na tabela de símbolos, e me deparo com a
forma gramatical através da qual identifico variáveis globais:

#+BEGIN_EXAMPLE
var_global: tipo_estatico lista_identificadores_globais ';' ;

lista_identificadores_globais:  identificador_global
         | identificador_global ',' lista_identificadores_globais ;

identificador_global:    TK_IDENTIFICADOR 
         | TK_IDENTIFICADOR '[' TK_LIT_INT ']' ;
#+END_EXAMPLE

Dado que o reconhecimento da entrada é ascendente e da esquerda para a
direita, como posso definir o tipo do nodo dos identificadores globais
pertencentes à lista se apenas terei essa informação após toda a lista
ser processada na entrada?

Em outras palavras, a ordem na qual estas regras são processadas para
a entrada "int x,y;", por exemplo, é primeiro o reconhecimendo do tipo
"int", e depois os identificadores "x" e "y". Ao meu ver, isto requer
o uso de um atributo herdado da lista de identificadores, o que
levaria a um esquema L-atribuído, requerindo regras internas, como na
possível solução:

#+BEGIN_EXAMPLE
var_global: tipo_estatico {lista_identificadores_globais->tipo = tipo_estatico->tipo}
            lista_identificadores_globais {/*Insere na tabela de simbolos*/}';'
#+END_EXAMPLE

Esta interpretação é correta ou estou realizando algum equívoco? Caso
a interpretação esteja correta, isto é permitido no contexto do
trabalho?

*** Dúvida #2

Notei que nesta etapa não foi dado um arquivo "main.c" para que sejam
realizados os testes. Podemos então usar (e inclusive realizar a
entrega desta etapa com ele) o mesmo arquivo da etapa 3?

*** Dúvida #3

Enquanto atribuia os tipos correspondentes às palavras reservadas int,
float, etc. fiquei com dúvida quanto aos especificadores de tipo, isto
é, "const" e "static". Esta informação deve ser guardada em algum
lugar, ou devemos realizar algum tratamento especial nestes casos?

** DONE 2020-10-13 D1
*** Dúvidas #1

Boa noite professor, surgiram algumas dúvidas rápidas de se responder
sobre a etapa 4, se for mais conveniente nem precisa fazer um vídeo
sobre elas:

1) Os operadores unários "*"(Resolução de ponteiro) e "#"(Acesso a
   tabela hash) esperam qual tipo de identificador operando?

2) O operador ternário (exp ? exp : exp) requer que as expressões
   resultantes tenham o mesmo tipo (ou pelo menos tipos compatíveis)?

3) Funções podem ser recursivas? Em termos mais técnicos, devo inserir
   a declaração da função tanto na tabela de símbolos do seu escopo
   quanto na do escopo global?

4) Para realizar a transferência dos tipos entre variáveis estou
   usando um novo campo na union dos tokens, que contém o tipo das
   palavras reservadas "int", "float", etc. Isto é permitido?
** DONE 2020-10-14 D2
*** Dúvida #1

1) Podemos usar C++ ou o flex/bison suportam apenas C?

*** Dúvida #2

2) Segundo o enunciado, precisamos guardar literais na tabela de
   símbolos. Por que isso é necessário?
** DONE 2020-10-16 D3
*** Dúvida #1

Sobre a etapa 4, retornando na questão dos literais na tabela de
símbolos: o que não ficou muito claro pra mim é como lidar com
múltiplas ocorrências de um mesmo literal? Digamos que na passagem
pelo código fonte eu encontre o literal 2 e adicione ele na tabela
hash, e mais adiante eu encontre outro literal 2. Essa ocorrência é
adicionada na tabela hash (com alguma informação adicional, como
número da linha, para distinção) ou eu simplesmente ignoro e mantenho
sempre a primeira ocorrência?

*** Dúvida #2

Como dito no ultimo vídeo de dúvidas, devemos adicionar literais na
tabela. Como tratamos literais iguais? devemos adicionar multiplas
vezes? ou deixar apenas a que já temos? se for manter a anterior,
devemos alterar algo nos dados dela?

*** Dúvida #3

Como poderemos aceitar expressão de (string + string), adicionei na
gramática a possibilidade de char e string dentro das expressões, para
que esse caso seja permitido enquanto outras operações, e
transformações com esses tipos causem erro. Gostaria de saber para
casos como (string * string), por exemplo, que tipo de erro devemos
retornar? (dizer que está sendo feita alguma conversão da string e
utilizar o ~ERR_STRING_TO_X~?)

*** Dúvida #4

Na parte de conversão explicita, quando diz que "a conversão de um
float para int perde sua parte fracionária", é só uma explicação do
que será feito eventualmente no desenvolvimento do compilador?, não
devemos tentar alterar esse valor na tabela de nenhuma forma agora,
correto?

*** Dúvida #5

Para funções que tem retorno string, temos que definir o tamanho desta
com a maior string de retorno encontrada no corpo de uma função? Se
sim, se houver uma função recursiva com retorno string, isso pode
causar problemas por possivelmente não ter o valor "máximo" de retorno
até um determinado momento?

*** Dúvida #6

No caso de vetores de string, como tratamos o tamanho para os
elementos strings?


** TODO 2020-10-17 D4
*** Dúvida #1

(...) teria mais um questionamento sobre strings. Strings vazias ("")
teriam um tamanho 0. Se a inicialização de uma variavel do tipo string
for com uma string vazia, deveriamos trancar o tamanho das strings em
0 também?  Não sabia como definir isso, e estou atribuindo tamanho -1
às strings sem inicialização, para que não tenha conflito em saber se
ela não foi inicializada ou FOI inicializada com uma string vazia,
isso estaria certo, ou a string deve ter seu tamanho > 0 quando algo
seja atribuido à ela?

*** Dúvida #2

O que é esperado para um caso de declaração local da seguinte forma:

int a <= a; (em que a não foi declarado anteriormente), isso seria
valido na linguagem? Um outro caso parecido:

int a <= 0, b <= a; este caso deveria ser valido, correto? 

*** Dúvida #3

Sobre aquele caso de um vetor de strings, você comentou no vídeo de
dúvida anterior que para cada elemento string teriamos um tamanho (o
que concordo), mas estou em dúvida quanto a implementação disso. Havia
falado com um colega e pensamos em definir um elemento a mais na
tabela de símbolo para esse caso específico, que manteria a informação
de tamanho para cada posição.

Porém, vetores, em atribuições, por exemplo, podem ser indexados a
partir de uma expressão, a qual não sabemos nessa etapa qual indice
corresponderia no vetor. Com isso, não sabendo o indice do vetor, como
que seria avaliada uma atribuição para um elemento string desse vetor?

*** Dúvida #4

Na mesma linha da pergunta do vídeo anterior sobre como proceder
quando o retorno da função é do tipo string, o que devemos fazer
quando houver um argumento do tipo string, visto que só saberemos seu
tamanho no momento da chamada da função?

*** Dúvida #5

Uma variável pode ter o mesmo nome de uma função, já que é possível
verificar a natureza do identificador pelo contexto (se é seguido por
() ou não)?
*** Dúvida #6

Pelo que entendi, se estiver em uma atribuição/inicialização e tiver
um tipo string recebendo outro tipo que diferente de string, temos um
erro ~ERR_WRONG_TYPE~. E, se estiver em uma operação cujos operandos são
do tipo string e int, por exemplo, temos um erro
~ERR_STRING_TO_X~. Correto? Com isso, se houver uma operação com uma
string e um char, qual erro deve ser dado ~ERR_CHAR_TO_X~ ou
~ERR_STRING_TO_X~?
