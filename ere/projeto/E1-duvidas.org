#+TITLE: Dúvidas Projeto de Compilador
* E1
** DONE 2020-08-26

 1) A descrição do padrão de identificadores é a seguinte:

 Os identificadores da linguagem são formados por um caractere
 alfabético seguido de zero ou mais caracteres alfanuméricos, onde
 considera-se caractere alfabético como letras maiúsculas ou minúsculas
 ou o caractere sublinhado e onde dígitos são 0, 1, 2, ..., 9.

 Sendo assim, uma sequência de caracteres sublinhada de qualquer
 tamanho sem nenhuma letra ou dígito é um identificador válido?
 Exemplo: __

 2) Na forma de notação científica do float tem um número positivo ou
    negativo depois do (e|E). Quando o número é positivo é obrigatório
    que ele tenha o sinal +? Ou pode não ter?

 3) O conteúdo de um char pode ser qualquer caracter? Em termos de
    regex, podemos usar o ponto para definir o conteúdo de um char?

 4) O conteúdo de uma string pode ser qualquer caracter? E devemos nos
    preocupar em escapar aspas dentro da string? E com outros
    caracteres especiais, como \n e \t?

 5) Quais caracteres devem ser ignorados? Somente espaço, \n e \t?

 6) Ao testar o input inválido "1nv4l1d0" (que é inválido porque seria
    um identificador começando com número), o nosso trabalho não
    retornou o token de erro, mas sim dois tokens: ~TK_LIT_INT~ [1] e
    ~TK_IDENTIFICADOR~ [nv4l1d0]. Esse comportamento é aceitável? Ou
    devemos incrementar as regras para delimitar limites entre os
    tokens? Se tivermos que delimitar limites entre os tokens, quais
    são os padrões que encerram um token? Caracteres em branco e
    especiais? Ou mais alguma outra coisa?

** DONE 2020-08-28
*** Pergunta #1
 mas um comportamento do analisador no terminal nos deixou com uma dúvida.

 O problema ocorre quando acontece um comentário do tipo composto
 #+BEGIN_EXAMPLE
/* Comentario */
 #+END_EXAMPLE
 No terminal o comportamento é o seguinte:

 #+BEGIN_EXAMPLE
$ ./etapa1
// lucas
float
2 TK_PR_FLOAT [float]
int
3 TK_PR_INT [int]
x = 3 ;
4 TK_IDENTIFICADOR [x]
4 TK_ESPECIAL [=]
4 TK_LIT_INT [3]
4 TK_ESPECIAL [;]
/* Lucas */
float
int
x = 3;
 #+END_EXAMPLE

 Note que após o uso do comentário o programa não responde mais em
 tempo real os tokens, finalizado o programa com Ctrl + D aparece os
 valores:

 #+BEGIN_EXAMPLE
6 TK_PR_FLOAT [float]
7 TK_PR_INT [int]
8 TK_IDENTIFICADOR [x]
8 TK_ESPECIAL [=]
8 TK_LIT_INT [3]
8 TK_ESPECIAL [;]
 #+END_EXAMPLE

 Acontece que quando esse mesma simulação é feita com um arquivo txt
 esse comportamento é ocultado visto que a resposta só é dada no fim do
 arquivo.

 Gostaríamos de saber se esse comportamento é esperado, ou estamos com
 um erro no nosso Trabalho.
*** Pergunta #2

Quais caracteres representam esses tokens?
#define ~TK_OC_FORWARD_PIPE~ 289
#define ~TK_OC_BASH_PIPE~    290

*** Pergunta #3

Tenho uma dúvida que para mim não ficou clara na especificação do E1.
Para identificar tokens literais do tipo string, é permitido que essa
string tenha o par de aspas em linhas diferentes?

Por exemplo:
"essa string
eh valida"

deve ser um token válido?

*** Pergunta #4

Em relação ao retorno de erro. Fica um tanto confuso o que exatamente
tratar como erro. Exemplo que foi abordado no video de dúvidas:

12nome;

É correto retornar o ~TK_LIT_INT[12]~ e ~TOKEN_ERRO [nome]~,
ou teria que se retornar um erro só?

Não seria melhor retornar dois tokens válidos (~TK_LIT_INT[12]~ e
~TK_IDENTIFICADOR[nome]~) que deixar para a análise sintática retornar
um erro de sintaxe?

PS: É preferível que eu mande as minhas dúvidas por email ou no forum
do moodle?

*** Pergunta #5

1. Sobre a parte de notação científica de float, devemos considerar um
   caso como 25E-4 Float ou para a notação precisamos que exista um
   ponto '.' pra descrever ele, como -2.5e-3?

2. Em relação a Strings, devemos tratar strings sem aspas finais ("ex
   string aberta) como um erro total de string ou se podemos apontar
   que as aspas iniciais correspondem ao erro (e que o restante dessa
   string aberta corresponda a outras coisas)?

*** Pergunta #6
sobre a etapa 1 do projeto de compiladores, eu queria saber se é
necessário retornar erro quando se abre aspas, mas não fecha, tipo
"teste ou 't
** DONE 2020-08-30
*** Pergunta #1

Apesar dos diversos testes que estamos fazendo para assegurar o
correto funcionamento do scanner, pensei que seria interessante para
todos se você fornecesse um arquivo de teste e o correspondente output
esperado com alguns "corner cases". Acho que diversas dúvidas de
interpretação da especificação seriam resolvidas assim. Seria
apropriado? Seria possível?

*** Pergunta #2

Estou com algumas dúvidas sobre o trabalho de compiladores:

1) Conforme os vídeos de dúvidas anteriores, as sequências "10." e
   "10.e" não podem ser reconhecidas como float. Assim, elas devem ser
   tratadas como erro, ou o analisador pode reconhecer ~TK_LIT_INT[10]~
   ~TK_ESPECIAL[.]~ e ~TK_LIT_INT[10]~ ~TK_ESPECIAL[.]~ ~TK_IDENTIFICADOR[e]~,
   e tratar esses erros em etapas futuras?

2) Os caracteres especiais que o analisador deve reconhecer são apenas
   os 24 listados na especificação, ou devemos incluir também os
   caracteres que aparecem no switch da função main e não estão na
   seção 3.2?

*** Pergunta #3

   Qual é exatamente o lexema da string e charater? Pelo o que entendi,
   não fariam parte deles seus delimitadores, isto é, " e ', e assim eu
   deveria retornar como match somente a sessão de caracteres entre
   esses delimitadores.

   Além disso, sobre esses literais, tenho dúvidas sobre o critério de
   erro definido no último vídeo. Nele você comenta sobre como, ao
   encontrar uma string aberta, deveríamos retornar o ponto do erro como
   a primeira aspa dupla, o que implicaria que continuaríamos
   reconhecendo as próximas palavras como quaisquer outros possíveis
   tokens. Enquanto, de fato, ambos clang e gcc retornem como ponto do
   erro a primeira aspa dupla, eles não reclamam sobre a falta de
   sentido sobre os próximos tokens, o que me leva a crer que eles
   reconhecem todos os caracteres desde a aspa dupla até o final da
   linha como um token de erro. Não seria uma melhor escolha
   implementarmos o comportamento dessa maneira?

*** Pergunta #4

   Não me ficaram muito claros os detalhes sobre componentes finais da
   nossa entrega. Isto é, entendi que precisamos entregar um diretório
   com um Makefile pronto para construir o executável que será testado,
   mas onde esse executável precisa ser criado (na raiz ou numa pasta
   build ou release ou entrega)? E qual deve ser o nome dele? Precisamos
   fornecer alguma documentação adicional junto a esse diretório, fora a
   documentação do código?

*** Pergunta #5

enquanto fazia o trabalho surgiram algumas dúvidas sobre o uso de +/-
na sinalização de inteiros/floats.

Ao digitar algo do tipo "1+2" (sem espaço algum) existem duas formas
de retornar os tokens:

~TK_LIT_INT[1]~
~TK_LIT_INT[+2]~

ou então
~TK_LIT_INT[1]~
~TK_ESPECIAL[+]~
~TK_LIT_INT[2]~

Qual das maneiras seria a forma correta de separar esta entrada?

*** Pergunta #6

Para o exemplo 123-123 nosso analisador esta identificando
~TK_LIT_INT[123]~ e ~TK_LIT_INT[-123]~. Esse comportamento está correto, ou o
esperado seriam três tokens: ~TK_LIT_INT[123]~ ~TK_ESPECIAL[-]~ ~TK_LIT_INT[123]~?
** TODO 2020-08-31
*** Pergunta #1

Professor, no vídeo respondeste uma pergunta sobre os caracteres
especiais, explicando que haviam na verdade 28 caracteres (e até
mostrou uma definição com 2, mas na definição que temos disponível no
moodle existem de fato apenas 24 caraceteres listados (os caracteres
'?', '~', '@' e '`' não estão presentes). Qual das definições é a
válida ?

*** Comentário sobre a questão do ~TOKEN_ERRO~
